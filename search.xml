<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CocoaPods 1.8.X pod install/update提示“[!] CDN: trunk Repo update failed”]]></title>
    <url>%2F2020%2F02%2F25%2FiOS%2FCDN-trunk-Repo-update-failed%2F</url>
    <content type="text"><![CDATA[问题描述在升级CocoaPods到1.8.X后，CocoaPods添加了CDN为默认的Spec repo源，而非原来以https://github.com/CocoaPods/Specs.git为默认source，来缓解git上的specs过大带来的效率下降问题。这个改动造成了我在家中pod install/update的时候无法正常运行。 提示错误：[!] CDN: trunk Repo update failed以及失败的pods列表 解决方案网上关于这个问题的出现原因多半都是因为在中国大陆GFW的CDN拦截/访问控制等造成的Pods更新中遇到未知错误导致的。解决办法都是强制Podfile使用原来位于git的source地址(https://github.com/CocoaPods/Specs.git)。 1.方法是在Podfile中添加代码，source &#39;https://github.com/CocoaPods/Specs.git 2.在命令行中运行pod repo remove master来删除Pod中的CDN源。 但是这样我们将无法享受到CDN带来的pod install/update速度变快的优势。 此外家里电脑具有“科学上网”能力，理论上不应该会导致该问题的出现。 ####我电脑上该问题的出现原因和解决办法 原因是我的本地系统的网络配置被之前安装的“科学上网”软件修改了，导致proxy异常而无法正确访问CocoaPods的CDN地址。 方法是关闭网络配置中当前连接的高级设置中的代理设置。如下图： 关闭完代理设置后，就可以正常访问CocoaPods的CDN地址，正常使用pod install/update了。 References[!] CDN: trunk Repo update failed]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS13Lame压缩录音文件为MP3格式闪退]]></title>
    <url>%2F2019%2F09%2F30%2FiOS%2FiOS13Lame%E5%8E%8B%E7%BC%A9%E5%BD%95%E9%9F%B3%E6%96%87%E4%BB%B6%E4%B8%BAMP3%E6%A0%BC%E5%BC%8F%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[问题描述我们项目在语音发送用户评语时，使用了Lame三方库对客户端的pcm录音文件进行压缩，输出MP3文件。具体的Lame接入方法可以参考该文章 “iOS-Lame-Audio-transcoding“. 在iOS13的iPhoneX/iPhoneXS等iPhone机中出现录音边录边压缩时闪退的问题。 问题类型EXC_BAD_ACCESS野指正，对象过早被释放导致。 异常出现的位置在lame_encode_buffer_interleaved方法调用中，该方法为Lame提供的方法，且输入的参数也没有发现野指针存在。Zombie调试没有发现有用的信息。刚开始考虑是Lame库太老了（我们还在使用4年前的库😅），更新了Lame库没有解决问题。 尝试运行iOS-Lame-Audio-transcoding中提供的Demo，在我的设备中没有出现闪退现象。基本排除了Lame三方库的问题。 问题根源和解决办法对比demo和项目中对Lame库的使用，意外发现了我们在AVAudioRecorder初始化的setting参数有一句差异，项目中多了一句 [settingDictionary setObject:@(YES) forKey:AVLinearPCMIsFloatKey]; 用于设置是否使用浮点数采样。 由于打开了浮点数采样导致了Lame压缩转换MP3时出现闪退。具体Lame中为何会出现浮点数采样转换Crash原因不明。怀疑是浮点数位数或者其他一些区别，导致Lame不适配。 记录下问题解决方式，方便新手排坑，欢迎大神指点。感谢🙏 ReferenceiOS-Lame-Audio-transcoding]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>闪退</tag>
        <tag>iOS13</tag>
        <tag>iPhoneX</tag>
        <tag>iPhoneXS</tag>
        <tag>Lame</tag>
        <tag>音频</tag>
        <tag>压缩</tag>
        <tag>MP3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree和GitLab配合使用的问题]]></title>
    <url>%2F2019%2F06%2F19%2FiOS%2FSourceTree%E5%92%8CGitLab%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述在使用SourceTree管理GitLab的时候出现了无法添加Repository 1This is not a valid source path / URL 或者无法Pull or Push的情况。 12remote: HTTP Basic: Access deniedfatal: Authentication failed for &apos;https://gitlab.xxx/xxx.git/&apos; 解决办法首先在添加或者pull/push的时候需要使用对应的Clone with SHH的地址如：“git@gitlab.xxx/xxx.git”，而不是Clone with HTTPS的地址。 如图： 其次，在MacOS中，SourceTree的Preference中并不提供指定公私钥的配置。我们需要在生成公私钥的时候对私钥进行ssh-add，如：ssh-add id_rsa 同时在公司gitlab页面上设置好SSH使用的私钥对应的公钥。 ReferenceMac 下source tree 与 gitlab 添加 ssh 密钥]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>SourceTree</tag>
        <tag>GitLab</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView的坑之iOS9以下版本退出闪退]]></title>
    <url>%2F2019%2F04%2F25%2FiOS%2FWKWebView%E7%9A%84%E5%9D%91%E4%B9%8BiOS9%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AEscrollView-delegate%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%80%80%E5%87%BA%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[问题描述在iOS9及以下版本中，WKWebView在自定义了他的scrollView.delegate为当前ViewController时，如果退出当前ViewController会闪退。提醒EXC_BAD_ACCESS错误并且闪退， 错误堆栈是-[UIScrollView(AdhocVisualEdit) adhoc_scrollViewSetDelegate:] 上一级是-[WKScrollView _updateDelegate]。 原因分析考虑是在iOS9及以下版本中，苹果对于delegate的weak的处理没有如预期。导致在退出当前ViewController的时候更新scrollView的delegate还是使用了已经释放的ViewController，从而导致EXC_BAD_ACCESS错误而闪退。 这个问题在iOS10及以上版本中已经修复，不再闪退。 解决办法在当前ViewController释放的时候，设置WKWebView的scrollView.delegate为nil。 代码如下： 12345678910// Objective-C- (void)dealloc&#123; _webView.scrollView.delegate = nil;&#125;// Swiftdeinit &#123; webView.scrollView.delegate = nil&#125; Reference ListiOS WKWebView.scrollView delegate cause BAD_ACCESS]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>WKWebView</tag>
        <tag>scrollView</tag>
        <tag>delegate</tag>
        <tag>闪退</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发实用工具]]></title>
    <url>%2F2019%2F04%2F23%2FiOS%2FiOS%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[iOS开发实用工具Chisel一款由Facebook分享的丰富LLDB命令的开源工具，具体的安装方法和介绍参考官方github。 通过该工具我们可以快速定位当前显示的图层层级，展示任意UIImage /CGImageRef /UIView等对象的内容，显示某个对象的响应链等各种功能。大大提高我们在debug时的效率。尤其对于视图相关的问题，相比Xcode提供的Debug View Hierarchy功能，Chisel能提供更快速的响应和更加直观和针对性的显示。而Debug View Hierarchy则更加的形象。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Utilities</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让App在iOS12中支持Siri Shortcuts(捷径)功能 和 “设置和捷径App内未列出自己App的Shortcut” 的解决办法]]></title>
    <url>%2F2018%2F10%2F10%2FiOS%2F%E8%AE%A9App%E5%9C%A8iOS12%E4%B8%AD%E6%94%AF%E6%8C%81Siri-Shortcuts-%E6%8D%B7%E5%BE%84-%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近发现的问题 “设置和捷径App内未列出自己App的Shortcut” 的解决办法在文章末尾 背景介绍WWDC 2018 苹果更新了Siri使其支持Shortcuts功能，中文名“捷径”。支持用户通过自定义把一系列操作合并到一个Shortcut内。苹果官方应用提供了一些接口供Shortcut调用，如Map应用的“获取行程时间”，“显示路线”等。如果我们的应用需要支持，需要自己在App中开放可以被Shortcuts访问的接口。同时苹果正在大力推广这个Siri新功能，支持软件可在苹果App Store榜单“用 Siri，走捷径”中列出，有一定推广作用。该功能也有利于增加用户粘度和活跃人数。 Apple提供了官方关于Shortcuts的demo，但是在苹果大力推广Swift的浪潮下，demo的语言也是Swift版的，无奈公司现在还在使用Objc，下面介绍下Objc下的接入过程。 创建Custom Intent在项目中通过“New File…”创建一个Intents.intentdefinition文件。这个文件用来定义自定义intent类型。 同时会自动在项目的Info.plist文件中添加NSUserActivityTypes 添加Frameworks在项目的Build Phases中的Link Binary With Libraries中添加Intents.framework和IntentsUI.framework。 添加Shortcut按钮在项目中需要调用添加Shortcut按钮的.m文件中， 增加import123#import &lt;Intents/Intents.h&gt;#import &lt;IntentsUI/IntentsUI.h&gt;#import "HWTakePhotoIntent.h" //上方“设置Custom Intents”图中右边箭头指的“Class Name” 添加Delegate123&lt;INUIAddVoiceShortcutButtonDelegate,INUIAddVoiceShortcutViewControllerDelegate,INUIEditVoiceShortcutViewControllerDelegate&gt; 添加Property12@property (nonatomic, strong) HWTakePhotoIntent API_AVAILABLE(ios(12.0)) *intent;@property (nonatomic, strong) INUIAddVoiceShortcutButton API_AVAILABLE(ios(12.0)) *shortcutButton; 添加shortcutButton按钮1234567if (@available(iOS 12.0, *)) &#123; _shortcutButton = [[INUIAddVoiceShortcutButton alloc] initWithStyle:INUIAddVoiceShortcutButtonStyleWhiteOutline]; _shortcutButton.shortcut = [[INShortcut alloc] initWithIntent:self.intent]; _shortcutButton.translatesAutoresizingMaskIntoConstraints = false; _shortcutButton.delegate = self; [self.view addSubview:_shortcutButton];&#125; 设置intent属性1234567- (HWTakePhotoIntent *)intent API_AVAILABLE(ios(12.0))&#123; if (!_intent) &#123; _intent = [[HWTakePhotoIntent alloc] init]; _intent.suggestedInvocationPhrase = @"开始改作业"; //在Siri语音设置时显示的建议设置唤起文字 &#125; return _intent;&#125; 设置对应delegate方法1234567891011121314151617181920212223242526272829303132#pragma mark - INUIAddVoiceShortcutButtonDelegate- (void)presentAddVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)addVoiceShortcutViewController forAddVoiceShortcutButton:(INUIAddVoiceShortcutButton *)addVoiceShortcutButton API_AVAILABLE(ios(12.0))&#123; addVoiceShortcutViewController.delegate = self; [self presentViewController:addVoiceShortcutViewController animated:YES completion:nil];&#125;- (void)presentEditVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)editVoiceShortcutViewController forAddVoiceShortcutButton:(INUIAddVoiceShortcutButton *)addVoiceShortcutButton API_AVAILABLE(ios(12.0))&#123; editVoiceShortcutViewController.delegate = self; [self presentViewController:editVoiceShortcutViewController animated:YES completion:nil];&#125;#pragma mark - INUIAddVoiceShortcutViewControllerDelegate- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)errorAPI_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:nil];&#125;- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:nil];&#125;#pragma mark - INUIEditVoiceShortcutViewControllerDelegate- (void)editVoiceShortcutViewControllerDidCancel:(INUIEditVoiceShortcutViewController *)controller API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:nil];&#125;- (void)editVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)controller didUpdateVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:nil];&#125;- (void)editVoiceShortcutViewController:(INUIEditVoiceShortcutViewController *)controller didDeleteVoiceShortcutWithIdentifier:(NSUUID *)deletedVoiceShortcutIdentifier API_AVAILABLE(ios(12.0))&#123; [controller dismissViewControllerAnimated:YES completion:nil];&#125; AppDelegate.m文件中添加方法12345678- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler&#123; // activityType 和 Info.plist中的NSUserActivityTypes内容对应 if ([userActivity.activityType isEqualToString:@"HWTakePhotoIntent"]) &#123; [HWNotificationCenter postNotificationName:kNotificationOpenCamera object:nil]; // 通过通知找到对应class处理activity &#125; return YES;&#125; 用于在Siri中通过设定语音调起应用时处理Siri的请求。我们的项目中是打开摄像头拍照批改作业。 iOS12 Siri Known Issues 如上图红框所示，iOS12发布后已知问题之一是系统的INUIAddVoiceShortcutButton只支持默认的标题“Add to Siri”和“Added to Siri”，没有做本地化支持😂。此外按钮的样式也很死，无法自由自在的自定义，所以灰溜溜的只能自己来写自定义按钮了。 需求一：判断是否添加过该shortcut来区别跳转INUIAddVoiceShortcutViewController还是INUIEditVoiceShortcutViewController当然苹果为我们提供了INVoiceShortcutCenter 的- (void)getAllVoiceShortcutsWithCompletion:(void(^)(NSArray&lt;INVoiceShortcut *&gt; * _Nullable voiceShortcuts, NSError * _Nullable error))completionHandler;方法来获得所有添加的Shortcuts或者- (void)getVoiceShortcutWithIdentifier:(NSUUID *)identifier completion:(void(^)(INVoiceShortcut * _Nullable voiceShortcut, NSError * _Nullable error))completionHandler NS_SWIFT_NAME(getVoiceShortcut(with:completion:));通过identifier查找对应的Shortcut。 我在项目中的按钮点击事件代码如下： 123456789101112131415161718192021222324252627- (void)shortcutButtonClicked:(UIButton *)sender&#123; if (@available(iOS 12.0, *)) &#123; [[INVoiceShortcutCenter sharedCenter] getAllVoiceShortcutsWithCompletion:^(NSArray&lt;INVoiceShortcut *&gt; * _Nullable voiceShortcuts, NSError * _Nullable error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; BOOL tempAddedShortcut = NO; for (INVoiceShortcut *voiceShortcut in voiceShortcuts) &#123; if ([voiceShortcut.shortcut.intent isKindOfClass:[HWTakePhotoIntent class]]) &#123; tempAddedShortcut = YES; break; &#125; &#125; self.addedShortcut = tempAddedShortcut; if (self.addedShortcut) &#123; INUIEditVoiceShortcutViewController *editVoiceShortcutViewController = [[INUIEditVoiceShortcutViewController alloc] initWithVoiceShortcut:voiceShortcuts[0]]; editVoiceShortcutViewController.delegate = self; [self presentViewController:editVoiceShortcutViewController animated:YES completion:nil]; &#125; else &#123; INShortcut *shortcut = [[INShortcut alloc] initWithIntent:self.intent]; INUIAddVoiceShortcutViewController *addVoiceShortcutViewController = [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortcut]; addVoiceShortcutViewController.delegate = self; [self presentViewController:addVoiceShortcutViewController animated:YES completion:nil]; &#125; &#125;); &#125;]; &#125;&#125; 需求二：通过INUIAddVoiceShortcutViewController和INUIEditVoiceShortcutViewController的Delegates更新自定义Shortcut按钮状态同样也需要用到需求一中提到的判断是否添加过当前Shortcut来更新对应的自定义Shortcut按钮样式。 “设置和捷径App内未列出自己App的Shortcut” 的解决办法问题描述按照上文介绍，一步步在自己的App中添加Shortcut功能成功后，我们并不能在系统的设置应用的Siri 与 搜索中看到我们刚刚添加的Shortcut，或者在捷径应用中找到。如下图： 如果我们通过上文中定义的App内的Add to Siri按钮添加用户的Shortcut到Siri成功后，我们依然可以在设置和捷径应用中看到。但是如果删除添加的Shortcut，有都会消失。这显然不是我们需要的效果。 预期效果是不管用户是否在App内添加Shortcut到Siri，都应在设置和捷径应用中看到。 解决办法我们需要自己手动更新我们应用的Shortcut Suggestions的内容，这样才能在设置和捷径应用中列出。 更新Shortcut Suggestions内容的代码如下。 12345678- (void)addMenuItemShortcuts&#123; if (AVAILABLE(12.0)) &#123; HWTakePhotoIntent *intent = [[HWTakePhotoIntent alloc] init]; intent.suggestedInvocationPhrase = NSLocalizedString(@"SIRI_SHORTCUT_CORRECT_WORK", nil); [[INVoiceShortcutCenter sharedCenter] setShortcutSuggestions:@[[[INShortcut alloc] initWithIntent:intent]]]; &#125;&#125; 我是在AppDelegate的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions里做了初始化。 更新Shortcut Suggestions内容后，即使不在应用内添加Shortcut到Siri，在设置和捷径应用中仍能找到应用提供的Shortcut建议。 设置中的界面如下 点击捷径进入后如下 如果你需要，也可以在其他需要的时候更新Shortcut Suggestions内容。 总结Siri Shortcut大功告成 References:iOS12 Siri Shortcuts初探 Human Interface Guidelines - SiriKit Documentation - SiriKit]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS12</tag>
        <tag>Siri</tag>
        <tag>Shortcuts</tag>
        <tag>捷径</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView的坑之图片显示不完全]]></title>
    <url>%2F2018%2F08%2F20%2FiOS%2FWKWebView%E7%9A%84%E5%9D%91%E4%B9%8B%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%AE%8C%E5%85%A8%2F</url>
    <content type="text"><![CDATA[最近在做iPad Pro适配时遇到了WKWebView图片显示不完全的坑在显示网页中的大尺寸图片时，图片显示不完整，有些是下方不显示，有些是下方和右侧都不显示。流程如下 第一类情况在卡片出现时，显示了WKWebView上部内容。点击卡片下方展开按钮或者上划手势，展开卡片，可以看到更多网页内容，但是下方图片无内容成白色。滑动图片后网页内容图片刷新，显示正常，如下 第二类情况如果WKWebView的初始状态为不可见时，如下点击展开卡片，显示的图片只有左上角一小条，其他内容缺失，如下同样滑动后页面会刷新，图片显示恢复正常。 原因分析WKWebView相比UIWebView提高了页面渲染载入速度，其中也包括只对展示给用户可见的内容进行渲染，这样可以大大提高载入速度。如我遇到的图片问题，WKWebView会把图片分割成多块，如下图A-F六块区域。在第一类情况，由于A/B/C块都是用户可见区域，所以WKWebView对这三块区域进行了渲染，而D/E/F块都没有渲染。所以展开卡片时，他也呈现空白状态，图片缺失。第二类情况则是所有区域都不在用户可视范围内，所以他仅对A块渲染，展开后B/C/D/E/F都为空白，图片缺失。这个可以在XCode的Debug View Hierarchy中得到验证，完整渲染的有六个区域，第一种情况三个区域，第二种状况只有一种区域。 解决办法填坑办法就是强制让WKWebView重新渲染一次，代码如下 [_webView setNeedsLayout]; 我是在展开卡片时增加了WKWebView强制重新渲染的代码实现。而对于网上提到比较多的，在UITableView中添加WKWebView图片载入不全的情况可以在- (void)scrollViewDidScroll:(UIScrollView *)scrollView中增加强制重新渲染的代码来解决。声称这个坑在iOS11中得到了修复，但是我的11.3的iPad Pro还是遇到了这个问题😂，可能是我们的WKWebView操作没有触发重新渲染吧。 ———————————————– 编辑于20180821 ——————————————————-最近出现了在iOS 8.2系统下图片显示过大，超出屏幕的问题。可以通过addUserScript解决，如下12345NSString *jScript = @&quot;var meta = document.createElement(&apos;meta&apos;); meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;); meta.setAttribute(&apos;content&apos;, &apos;width=device-width&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta);&quot;;WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];WKUserContentController *wkUController = [[WKUserContentController alloc] init];[wkUController addUserScript:wkUScript];[[_webView configuration].userContentController addUserScript:wkUScript]; Reference ListWKWebView not rendering correctly in iOS 10使用WKWebView 适应屏幕尺寸]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>WKWebView</tag>
        <tag>图片显示不全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中通过CGContext实现图片围绕任意点旋转任意角度的功能]]></title>
    <url>%2F2018%2F07%2F24%2FiOS%2FiOS%E4%B8%AD%E9%80%9A%E8%BF%87CGContext%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%9B%B4%E7%BB%95%E4%BB%BB%E6%84%8F%E7%82%B9%E6%97%8B%E8%BD%AC%E4%BB%BB%E6%84%8F%E8%A7%92%E5%BA%A6%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[需求需要围绕任意点旋转若干角度返回和原始图片大小相同的图片。 实现代码如下：12345678910111213141516171819202122232425262728+ (UIImage *)getRotationImage:(UIImage *)image rotation:(CGFloat)rotation point:(CGPoint)point &#123; NSInteger num = (NSInteger)(floor(rotation)); if (num == rotation &amp;&amp; num % 360 == 0) &#123; return image; &#125; double radius = rotation * M_PI / 180; CGSize rotatedSize = image.size; // Create the bitmap context UIGraphicsBeginImageContext(rotatedSize); CGContextRef bitmap = UIGraphicsGetCurrentContext(); // rotated image view CGContextScaleCTM(bitmap, 1.0, -1.0); // move to the rotation relative point CGContextTranslateCTM(bitmap, point.x, -point.y); // Rotate the image context CGContextRotateCTM(bitmap, radius); // Now, draw the rotated/scaled image into the context CGContextDrawImage(bitmap, CGRectMake(-point.x, -image.size.height+point.y, image.size.width, image.size.height), [image CGImage]); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 输入：需要旋转的图片，旋转的角度，和旋转围绕的点。返回：旋转后同样大小的结果图片。 调试CGContext的时候需要注意几点，设置的CGContextScaleCTM, CGContextTranslateCTM, CGContextRotateCTM等方法改变的是上下文的坐标系参数；不同的设置顺序返回的最终自定义的坐标系结果也是不尽相同。在调适的时候，由于设计的坐标系调整相对复杂，对已有的方法做调整可能牵一发而动全身，无法知道之间的必然联系。建议先思考自己需要的图片调整结果的理想步骤，再逐步实现并测试每步步骤，一步步达到最终效果。😂不过应该是我不太熟悉，调了好久，期间都快挠破头皮，最终才实现需要的效果。 ReferenceCGContext图形上下文详解CGContext-上下文（画布）的应用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CGContext</tag>
        <tag>围绕任意点</tag>
        <tag>旋转任意角度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView通过监听ContentSize更新WebView的Frame导致Height持续增长的bug解决方案（编辑于2018081]]></title>
    <url>%2F2018%2F07%2F19%2FiOS%2FWKWebView%E9%80%9A%E8%BF%87%E7%9B%91%E5%90%ACContentSize%E6%9B%B4%E6%96%B0WebView%E7%9A%84Frame%E5%AF%BC%E8%87%B4Height%E6%8C%81%E7%BB%AD%E5%A2%9E%E9%95%BF%E7%9A%84bug%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E7%BC%96%E8%BE%91%E4%BA%8E2018081%2F</url>
    <content type="text"><![CDATA[问题描述最近眼红WKWebView相对UIWebView的高可配置和高效。在最近的代码中选择使用WKWebView来加载JS动态页面。但是需要把WebView嵌入到另一个ScrollView中显示，所以需要拉伸到内容长度且不能被用户拖动。原始代码如下：123456789- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; [webView evaluateJavaScript:@&quot;document.body.scrollHeight&quot; completionHandler:^(NSNumber *height, NSError * _Nullable error) &#123; float htmlHeight =[height floatValue]; CGRect webFrame = webView.frame; webFrame.size.height = htmlHeight; webView.frame = webFrame; [self addFeedBackBtn]; &#125;];&#125; 通过JS代码得到页面的高度。但是这样的方法对于非静态页面无效，高度并非正确的高度。 解决办法 编辑于20180813下面的分割线后是最初始的解决办法，但是在部分极端情况下还有用户反应会出现高度持续增长的问题。最终找到的原因是WKWebView的frame宽度带有小数，而不是整数。猜测WKWebView在计算contentSize的时候是依照frame.width向下取整的宽度来计算最终的contentSize的height的，然后导致KVO观察的contentSize高度在更新frame高度后持续增加。更新的解决办法是对WKWebView的frame宽度求整。 代码如下_webView.frame = CGRectMake(HWFrame_IPhonePadX(20, 30), height, (NSInteger)(ScreenWidth - HWFrame_IPhonePadX(60, 80)), 0);。 BTW. 之所以我们的WKWebView的frame宽度会带小数是因为我们的HWFrame_IPhonePadX宏会自适应屏幕宽高生成输入数值对应的实际显示数值（这个数字是比例计算而来，会带有小数位）。所以就尴尬了，产生了WKWebView高度持续增加的bug。 初始解决方案为了监控JS动态页面的当前高度，选择使用KVO监听WKWebView.scrollView的contentSize变化。在收到变化通知是，通过当前的contentSize更新webView的frame。代码如下： 12345678- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if (object == _webView.scrollView &amp;&amp; [keyPath isEqualToString:@"contentSize"]) &#123; NSLog(@"_webView.scrollView.contentSize %f %f", self.webView.scrollView.contentSize.width, self.webView.scrollView.contentSize.height); CGRect webFrame = self.webView.frame; webFrame.size.height = self.webView.scrollView.contentSize.height; self.webView.frame = webFrame; &#125;&#125; 该方法可以基本解决访问动态页面，实时更新页面高度的问题。 使用KVO记得移除Observer，同时避免过度移除的crash。可以使用下方代码解决12345678910- (void)removeWebViewObserver &#123; @try &#123; if (_webView) &#123; [_webView.scrollView removeObserver:self forKeyPath:@"contentSize"]; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@"多次删除kvo 报错了"); &#125;&#125; 偶发问题上方方法小概率下会出现监听持续被触发，contentSize.height持续不断增加，从而使得设置的frame的高度也在不断增加，无限循环增高。我当时工程内的表现为高度每次加一。 解决方案一通过12345678- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if (object == _webView.scrollView &amp;&amp; [keyPath isEqualToString:@"contentSize"]) &#123; NSLog(@"_webView.scrollView.contentSize %f %f", self.webView.scrollView.contentSize.width, self.webView.scrollView.contentSize.height); CGRect webFrame = self.webView.frame; webFrame.size.height = self.webView.scrollView.contentSize.height - 1; // 每次减一可以结局死循环，持续增加高度。 self.webView.frame = webFrame; &#125;&#125; 该办法可以解决持续增加高度的问题。但是没有找到根本原因，无法确定所有页面都是每次加一，还是有其他可能的情况。所以该方法放弃。 解决方案二把WKWebView更换为UIWebView，同样也通过监听contentSize来动态更新webView高度，没有出现上方的偶发问题，高度不会持续增加。但是WKWebView比UIWebView更加高效和苹果更加推荐，所以也放弃。 解决方案三测试代码，发现如果不仅仅更新frame的height，取而代之的通过contentSize同时更新webView的frame的宽高，就不会出现高度的持续增高。但是页面内容宽度会失去限制，超过webView页面范围。 最终解决方案是通过JS代码限制webView的内容宽度。方案是不更改监听代码，也不对监听得到的高度减一。更新WKNavigationDelegate的- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation如下：123456789101112- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123; if (webView == _webView) &#123; NSString *meta = [NSString stringWithFormat:@&quot;document.getElementsByName(\&quot;viewport\&quot;)[0].content = \&quot;width=self.webView.frame.size.width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\&quot;&quot;]; [_webView evaluateJavaScript:meta completionHandler:^(id _Nullable complete, NSError * _Nullable error) &#123; if (complete != nil) &#123; NSLog(@&quot;complete %@&quot;, complete); &#125; else if (error) &#123; NSLog(@&quot;error %@&quot;, error); &#125; &#125;]; &#125;&#125; 通过强制设置页面的宽度为我们当前的webView的宽度。解决偶尔出现的高度持续增加的Bug。 ReferenceHow to determine the content size of a UIWebView?iOS 修改webView字体大小,设置宽度及缩放效果]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>WKWebView</tag>
        <tag>监听</tag>
        <tag>ContentSize</tag>
        <tag>Height</tag>
        <tag>持续增长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error-1053--The-service-did-not-respond-to-the-start-or-control-reques]]></title>
    <url>%2F2018%2F05%2F02%2FPython%2FError-1053--The-service-did-not-respond-to-the-start-or-control-reques%2F</url>
    <content type="text"><![CDATA[最近在把Python的定时程序放进Windows服务时遇到了上述的问题‘错误1053：服务没有及时响应启动或控制请求’ 或者 ‘Error 1053: The service did not respond to the start or control request in a timely fashion’。可以正常安装python PythonFileName.py install，不能正常启动python PythonFileName.py start。尝试使用python PythonFileName.py debug检查代码，没有发现代码问题，考虑应该是环境问题。 最终在StackOverflow的 Can’t start Windows service written in Python (win32serviceutil) 中找到了 BuvinJ 的回答：“It might prove useful in this case to also add these directories to your system path: C:\Python27\Lib\site-packages\win32 and C:\Python27\Lib\site-packages\pywin32_system32. That will let you use pythonservice more easily. ” 解决办法在cmd中输入setx /M PATH &quot;%PATH%;C:\Python27;C:\Users\Administrator\Anaconda2\Scripts;C:\Users\Administrator\Anaconda2\Lib\site-packages\pywin32_system32;C:\Users\Administrator\Anaconda2\Lib\site-packages\win32&quot;回车，增加两个路径的引用。然后就能启动服务了。 具体的Windows服务Python代码：1234567891011121314151617181920212223242526272829303132333435import sysimport win32serviceutilimport win32serviceimport win32eventimport servicemanagerimport winerrorclass StockRecommendRunLoop(win32serviceutil.ServiceFramework): _svc_name_ = "StockRecommendRunLoop" _svc_display_name_ = "Stock Recommend Run Loop" def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) self.hWaitStop = win32event.CreateEvent(None, 0, 0, None) def SvcStop(self): self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) win32event.SetEvent(self.hWaitStop) def SvcDoRun(self): self.ReportServiceStatus(win32service.SERVICE_RUNNING) self.start_task() win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)if __name__ == '__main__': if len(sys.argv) == 1: try: servicemanager.Initialize() servicemanager.PrepareToHostSingle(StockRecommendRunLoop) servicemanager.StartServiceCtrlDispatcher() except win32service.error, details: if details[0] == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: win32serviceutil.usage() else: win32serviceutil.HandleCommandLine(StockRecommendRunLoop) Reference:Can’t start Windows service written in Python (win32serviceutil)Python Windows Service的方式运行]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Error-1053</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple-Watch-“密码错误”-问题解决-和-还原初始化方式]]></title>
    <url>%2F2017%2F09%2F19%2FApple%2FApple-Watch-%E2%80%9C%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E2%80%9D-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-%E5%92%8C-%E8%BF%98%E5%8E%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近莫名其妙遇到的Apple Watch无法解锁的问题这个问题几乎是一个死循环。首先手机的蓝牙无法正常的连接到曾经配对过的Apple Watch，同时手表提示“密码错误 请在 iPhone 打开Apple Watch 应用，前往Passcode，轻按“重启密码”再试。”。很尴尬，手机连不上手表，无法重启密码。手表所有按键都提示这段话。 晚上搜索了还原办法，多数说的是按住边上的电源键和表冠健，直到出现白苹果，再松开。但是尝试后并没有还原，依然还是这一段提示。之后联系了客服，才得知有另一种还原的办法：就是“长按电源键直到出现关机滑动条，此时不要滑动关机键，而是用力点击（force touch）关机条中间，之后便会出现‘抹掉内容并恢复出厂设置’按钮。”之后再用手机和手表配对，然后恢复备份就能搞定这个问题了。 [求助已解决]这是什么鬼？求解—————-已解决感谢楼主的图，原来楼下高人已经提供了这个还原办法，白和客服妹子聊了一小时天了$x + y = z$]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>Watch</tag>
        <tag>密码错误</tag>
        <tag>重启</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MMDraggableTagView实现排坑]]></title>
    <url>%2F2017%2F03%2F27%2FiOS%2FMMDraggableTagView%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近需要实现个MMDraggableTagView来实现类似网易新闻中的新闻类型管理或者其他的应用中标签管理页面，同时需要它最好能够拖拽，同时可以有层级关系。在工程中我们使用了 SnapKit 来管理autolayout的constraints，这个三方库和 Masonry 类似，只是 one for ObjC, one for Swift. 问题列表（Swift菜鸟问题，熟练工略过）1. 通过SnapKit，重复更新autolayout时，页面显示位置不正常最初采用public func makeConstraints(_ closure: (_ make: ConstraintMaker) -&gt; Void)来添加constraints，但是重复使用会遗留下之前添加的constraints。需要使用public func remakeConstraints(_ closure: (_ make: ConstraintMaker) -&gt; Void)来实现删除之前的constraints，并创建新的constraints。 2. 通过更新视图的constraints来实现视图的动画效果。一开始通过在UIView的animate block中实现constraints更新，但是并没有动画效果正确方法是：1234UIView.animate(withDuration: 0.2, animations: &#123; self.relocateTags() // update autolayout constraints by SnapKit. self.layoutIfNeeded() // call layout method if needed to update subviews.&#125;) 需要调用layoutIfNeeded()来更新子页面，不然其实子视图不会更新位置，只更新constraints。 3. 视图被拖拽时，出现视图因为之前的关联对象的位移，而产生同样的位移考虑是因为之前被拖拽视图设置的与周边子视图相关的constraints导致的。因此可以通过SnapKit中的public func removeConstraints()来直接删除所有的限制。但是因为删除了所有constraints，会导致视图移动到最初左上角的位置。因此采用了个折中的办法，1234draggingCell!.snp.remakeConstraints &#123; (make) in make.top.equalTo(self).offset(draggingCell!.frame.origin.y) make.left.equalTo(self).offset(draggingCell!.frame.origin.x)&#125; 更新他的constraints，删除与周边subviews相关的constraints，设置为与superview的相关关系。这样就不会因为相关的subviews的位置变化而影响自己的视图。 未完待续]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>MMDraggableTagView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo-gem-install-cocoapods更新CocoaPods失败、无权限的解决办法]]></title>
    <url>%2F2017%2F03%2F20%2FiOS%2Fsudo-gem-install-cocoapods%E6%9B%B4%E6%96%B0CocoaPods%E5%A4%B1%E8%B4%A5%E3%80%81%E6%97%A0%E6%9D%83%E9%99%90%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[sudo gem install cocoapods更新CocoaPods，或者sudo gem update --system更新gem。却提醒失败，无权限。但是已经加了sudo，考虑是路径问题。 解决办法用下面的代码指定路径就能安装成功了。sudo gem install -n /usr/bin/pod cocoapods安装CocoaPods或者sudo gem update -n /usr/local/bin --system安装Gem ReferenceOperation not permitted - /usr/bin/update_rubygems]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>sudo-gem-install-cocoapods</tag>
        <tag>无权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods-trunk-push发布成功后无法pod-search到]]></title>
    <url>%2F2017%2F03%2F20%2FiOS%2FCocoaPods-trunk-push%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E5%90%8E%E6%97%A0%E6%B3%95pod-search%E5%88%B0%2F</url>
    <content type="text"><![CDATA[现象：按照上一篇文章《MMNumberScrollView数字滚动动画视图和Cocoapods实践笔记》介绍，实现了新建并编辑podspace，然后通过pod trunk push yourSpaceName.podspec来push我们自己的CocoaPods库到CocoaPods官方git。 上传成功后，按照之前的文章介绍，可以使用pod search YouUploadCocoaPodsSpaceName 来找到你的工程。理应显示但是显示的是😂 解决办法：网上介绍这类的解决方法是pod setup来更新我们本地的CocoaPods space库，然后再用pod search便找到我们发布的工程。但是我使用后始终无效。 怀疑是否会是因为需要审核，可能需要些时间。但是今天发现依然如此，便进到CocoaPods官方git搜索，发现我的库已经被收录。 于是再次搜索解决方案，发现可能是本地的搜索时的本地缓存有问题。可以在终端中输入rm ~/Library/Caches/CocoaPods/search_index.json来清除缓存，再通过pod search YouUploadCocoaPodsSpaceName来搜索这样就可以搜索到自己发布成功的CocoaPods库了。 Reference：解决cocoapods安装完成后不能 pod search的问题]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>trunk</tag>
        <tag>push</tag>
        <tag>pod</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的CSDN博客地址]]></title>
    <url>%2F2017%2F03%2F16%2Fcsdn%2F</url>
    <content type="text"><![CDATA[原来CSDN博客地址michaelin1208。 懒得一篇篇文章搬运了，记录下方便以后查找😊。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>CSDN</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MMNumberScrollView数字滚动动画视图和Cocoapods实践笔记]]></title>
    <url>%2F2017%2F03%2F16%2FiOS%2FMMNumberScrollView%E6%95%B0%E5%AD%97%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB%E8%A7%86%E5%9B%BE%E5%92%8CCocoapods%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MMNumberScrollView数字滚动动画视图之前项目中需要一个动画显示礼物数字增长的视图。最近把它拿来修改下，共享出来。具体的代码可从 MMNumberScrollView in GitHub 下载。本数字滚动视图可以实现用户自定义滚动图案，滚动速度，和是否动态控制视图大小。12345678910111213141516171819202122232425262728293031#import &lt;UIKit/UIKit.h&gt;#import &quot;MMSingleNumberScrollView.h&quot;@class MMNumberScrollViewManager;@protocol MMNumberScrollViewManagerDelegate &lt;NSObject&gt;- (void)numberScrollViewManagerFinishedIncreasing:(MMNumberScrollViewManager *)manager; // delegate method is callbacked when the number scroll view manager finish a increasing operation.@end@interface MMNumberScrollViewManager:UIView &lt;UIScrollViewDelegate, MMSingleNumberScrollViewDelegate&gt;@property (nonatomic,strong) NSMutableArray *numImageArray; // a mutable array of number images shown in number scroll view.@property (nonatomic) NSTimeInterval speedDuration; // roll speed, the duration of each increasing scrolling. The default value is 1 second.@property (nonatomic) BOOL isShowingFinalSize; // is it show final size at beginning. Default value is &apos;YES&apos;, the size of scroll view is not increasing during scrolling.@property (nonatomic, weak) id&lt;MMNumberScrollViewManagerDelegate&gt; delegate;// increase number displayed in the manager&apos;s view from currentCount to targetCount.// You would better to start another increasing after last increasing operation finished (by &quot;- (void)numberScrollViewManagerFinishedIncreasing:(MMNumberScrollViewManager *)manager;&quot;)// or remove all existed number scroll views (&quot;- (void)removeAllNumberScrollViews;&quot;).- (void)increaseNumberFrom:(int)currentCount to:(int)targetCount;// init the number scroll view manager to contral all single number scroll views.- (instancetype)initWithFrame:(CGRect)frame;// remove all single number scroll views, if you want to shwo another number increasing.- (void)removeAllNumberScrollViews;@end Cocoapods实践笔记此外最近有些迷恋Cocoapods，最近都在尝试如何把自己的工程中自己工程中的三方库交给CocoaPods来管理。今天也顺道实践下怎么创建CocoaPods。方法可以参考下：创建CocoaPods的制作过程CocoaPods的安装使用和常见问题 没有遇到什么特别的问题，除了个别步骤需要翻墙，推荐下Lantern，虽然流量有上限，但是从来没超过。创建过程一切顺利，应该成功了，但是暂时在Cocoapods中还搜索不到我的工程。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Cocoapods</tag>
        <tag>数字滚动动画视图</tag>
        <tag>MMNumberScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果在WWDC2016上宣布的关于应用强制使用https的规定的解决方案]]></title>
    <url>%2F2017%2F01%2F10%2FiOS%2F%E8%8B%B9%E6%9E%9C%E5%9C%A8WWDC2016%E4%B8%8A%E5%AE%A3%E5%B8%83%E7%9A%84%E5%85%B3%E4%BA%8E%E5%BA%94%E7%94%A8%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8https%E7%9A%84%E8%A7%84%E5%AE%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[首先是还算好的好消息苹果官方表示：强制使用 HTTPS 的要求将暂时不执行，以便给我们更多的时间来做 HTTPS 的适配工作。具体的执行时间，将在确定后再次发布。因此，我们依然可以在 ‘xxx-Info.plist’ 中设置 ‘App Transport Security Settings’ 的 ‘Allow Arbitrary Loads’ 属性设置为yes，来避开ATS要求。这样我们的应用不再需要任何修改就可访问http的网页。 其次是出来混总要还的首先我们需要把网站配置成支持HTTPS。苹果的 ATS (App Transport Security) 政策对于HTTPS的要求，包括： X.509证书必须至少满足下面一种条件： 由根证书是操作系统安装的CA颁发； 由用户或系统管理员信任并安装的根证书颁发； TLS版本必须为TLS 1.2，不使用TLS或使用老版本TLS的连接，访问会失败，基于TLSTool工程可获取服务器支持的TLS相关参数； 连接必须使用AES-128或AES-256对称加密算法，TLS协商算法必须通过ECDHE密钥交换保证完全正向保密（Perfect Forward Secrecy, PFS），ECDHE密钥必须属于下面一种： TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 服务器叶证书必须使用下列的密钥签名： 至少2048位的RSA密钥； 至少256位的ECC密钥； 验证网站是否支持苹果的 ATS 要求对于OS X v10.11及以上系统，用户可以在终端中使用 /usr/bin/nscurl –ats-diagnostics –verbose https://www.baidu.com 来验证目标网站是否符合 ATS 要求，以及是否需要加入白名单。 此外，腾讯云也提供了验证是否符合ATS要求的验证 SSL 网页。 对于无法支持ATS的网站，尤其是第三方网站的适配方案。首先配置 ‘xxx-Info.plist’ 对于用户的 API 请求，苹果要求是必须使用 HTTPS 的，特别是当这个服务器是属于你们自己管理的话。那么这就需要服务器的同事尽快配置证书好让服务器支持 HTTPS 访问。如果使用的是第三方的 API，而他们没有提供 HTTPS 支持的话，需要在 NSExceptionDomains 中进行添加。具体的添加方式可以参考官方的 App Transport Security Technote，官方对他进行了具体的说明。 这些都可以在 ‘xxx-Info.plist’ 的 ‘NSAppTransportSecurity’ 中进行配置，具体的内容包括 NSAllowsArbitraryLoads - Bool类型 - 设置YES即可完全关闭ATS，以便支持所有HTTP请求，默认为NO。 NSAllowsArbitraryLoadsInWebContent - Bool类型 - 允许应用浏览网页内容时关闭ATS限制。默认为NO，像是 UIWebView 或 WKWebView 需要访问 HTTP 或者不安全的 HTTPS 时，需要设置为YES来允许访问。 NSAllowsArbitraryLoadsForMedia - Bool类型 - 允许该APP的 AVFoundation 中的 player 可以关闭 ATS 限制。默认为NO，如果媒体内容不支持 HTTPS 可打开该关键字。 NSAllowsLocalNetworking - Bool类型 - 设置本地网络请求不受 ATS 的限制，默认为NO。 NSExceptionDomains - Dictionary类型 - 添加白名单域名，对应不同的白名单中的网址设置他们的安全例外内容。需要例外的域名根地址 (不包括 ‘http://‘ 或 ‘https://‘ 的头和 ‘/‘ ) 作为关键字，Dictionary类型，内容为下面的参数。 NSExceptionMinimumTLSVersion - String类型 - 白名单指定域名支持的TLS版本，苹果要求必须达到TLS 1.2版本，如果你访问的网站仅支持TLS 1.0，那么设置为 ‘TLSv1.0’。 NSExceptionRequiresForwardSecrecy - Bool类型 - 白名单指定域名是否支持Forward Secrecy，默认值为YES，如果域名不支持完全正向加密，那么设置为NO。具体的加密要求可以阅读上方官方技术文档。 NSExceptionAllowsInsecureHTTPLoads - Bool类型 - 白名单指定域名禁用ATS，而不仅仅只是允许HTTP访问，默认是NO。 NSIncludesSubdomains - Bool类型 - 白名单指定该白名单的相关设置是否同样设置它的子域名，默认为NO。 ‘SDWebImage’ 无法下载图片的问题。在设置了白名单后，出现部分网上的图片无法通过 ‘SDWebImage’ 进行下载的问题。解决方法是在下载图片时，设置 ‘options’ 为 ‘SDWebImageAllowInvalidSSLCertificates’ 来允许SDWebImage类访问无效的SSL认证。 [self.headImageView sd_setImageWithURL:[NSURL URLWithString:headImageStr] placeholderImage:kCLDefaultHeadImage options:SDWebImageAllowInvalidSSLCertificates]; ‘AFNetworking’ 在 ATS 打开情况下，对于无效证书 (像是自建证书) 和不匹配域名的证书可能会请求失败，那么我们需要修改请求的安全要求，来允许无效证书和不匹配域名的证书。 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy]; //allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO//如果是需要验证自建证书，需要设置为YES securityPolicy.allowInvalidCertificates = YES; //validatesDomainName 是否需要验证域名，默认为YES； securityPolicy.validatesDomainName = NO; manager.securityPolicy = securityPolicy; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; [manager POST:urlString parameters:dic success:finishedBlock failure:failedBlock]; Reference List:“Supporting App Transport Security”, https://developer.apple.com/news/?id=12212016b “Apple’s Information Property List Key Reference”, https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html “苹果ATS（强制HTTPS）审核新政解码”, https://yq.aliyun.com/articles/62563 “iOS 中 AFNetworking HTTPS 的使用”, http://www.jianshu.com/p/20d5fb4cd76d “苹果新『应用通信安全』的理解和使用”, http://www.cocoachina.com/ios/20150717/12650.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>WWDC2016</tag>
        <tag>https</tag>
      </tags>
  </entry>
</search>
